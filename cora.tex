%------------------------------------------------
\section{APSP} 

\subsection{Idee} 

\begin{frame}
\frametitle{APSP - All Pairs Shortest Paths}
\begin{block}{Problemstellung}
Man hat einen Graphen gegeben, der gewichtet ist. Nun möchte man den kürzesten Pfad zwischen allen Knoten i zu allen Knoten j herausfinden, wobei i, j aus V sind.
\end{block}
\end{frame}

%------------------------------------------------

\begin{frame}
\frametitle{APSP - Erster Ansatz}
\begin{block}{Lösungsansatz}
Man verwendet den bereits bekannten SSSP-Algorithmus, und führe diesen nach bedarf aus, d.h. in diesem Fall |V|-mal.
\end{block}

\begin{block}{Laufzeit}
$|V| * O ((|E| + |V|) * log(|V|))$\\$
= |V| * O ((|V|^2 + |V|) * log(|V|))$\\$
= |V| * O ((|V|^2) * log(|V|)) $\\$
= O ((|V|^3) * log(|V|))$\\
$\implies$ geht es schneller?
\end{block}
\end{frame}

%------------------------------------------------

\begin{frame}
\frametitle{APSP - Zweiter Ansatz}
\begin{block}{Lösungsansatz}
Wir wissen: jeder Pfad zwischen zwei Knoten ist entweder bereits der kürzeste, oder es gibt einen Kürzeren Pfad als zwei Verknüpfung anderer Pfade über mindestens einen dritten Knoten.
\end{block}

\begin{block}{Genauer}
Systematisch in einer Adjazenzmatrix A:
Nehme für jeden Pfad $A[i][j] = \min\left(A[i][j], A[i][k] + A[i][k]\right)$, d.h. entweder der Pfad ist bereits minimal, oder ein Pfad über Knoten k ist kürzer und wird als neues Minimum übernommen.
Wenn man nun richtig iteriert, erhält man alle minimalen Pfade.
\end{block}
\end{frame}

%------------------------------------------------

\subsection{Code}

\begin{frame}[fragile] % Need to use the fragile option when verbatim is used in the slide
\frametitle{Code}

\begin{lstlisting}
for (int k = 0; k < V; k++)
    for (int i = 0; i < V; i++)
        for (int j = 0; j < V; j++)
            AdjMat[i][j] = min(AdjMat[i][j],
                AdjMat[i][k] + AdjMat[k][j]);
\end{lstlisting}

~\\$\implies$ der Aufwand liegt in $O(|V|^3)$

\end{frame}

%------------------------------------------------

\subsection{Weitere Anwendungen} 

\begin{frame}
\frametitle{Weitere Anwendungen}
\begin{itemize}

\item Auch für SSSP - Probleme anwendbar (wenn $\vert V \vert < 400$)
\item Detektion von negativen oder günstigsten Zyklen möglich $\implies$ setze die Diagonale auf Unendlich (hohen Wert)
\item Finden des Durchmessers eines Graphen (der längste der kürzesten Pfade)
\item Minimax, Maximin
\item Transitive Hülle berechnen (wer ist mit wen verbunden $\rightarrow$ bits)
\item Finden von starken Zusammenhangskomponenten
\item evtl. weitere Anwendungen in konkreten Fällen
\end{itemize}
\end{frame}

%------------------------------------------------

\subsection{Beurteilung} 

\begin{frame}
\frametitle{Beurteilung}
\begin{itemize}

\item[+] Asymptotische Komplexität $\in O(|V|^3)$  und mit Speicher $\in O(|V|^2)$
\item[+] Sehr leicht zu implementieren (Vierzeiler)
\item[+] Für andere Probleme günstig anzuwenden, wenn $|V|< 400$
\item[-- --] Für andere Probleme \textbf{nur} günstig anzuwenden, wenn $|V|< 400$
\end{itemize}
\end{frame}

%------------------------------------------------